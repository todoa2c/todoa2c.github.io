<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[技術情報棚卸し(平日限定)]]></title>
  <link href="http://todoa2c.github.io/atom.xml" rel="self"/>
  <link href="http://todoa2c.github.io/"/>
  <updated>2014-02-06T18:41:51+09:00</updated>
  <id>http://todoa2c.github.io/</id>
  <author>
    <name><![CDATA[Atsushi Kanaya (todoa2c)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[カスタム条件で二分探索したい]]></title>
    <link href="http://todoa2c.github.io/blog/2014/02/06/custom-bisect/"/>
    <updated>2014-02-06T16:46:42+09:00</updated>
    <id>http://todoa2c.github.io/blog/2014/02/06/custom-bisect</id>
    <content type="html"><![CDATA[<p>Pythonの<a href="http://docs.python.jp/3/library/bisect.html">bisect</a>の返す結果に戸惑った、
と同僚に話したところ、「いや他の言語のライブラリも大体同じですよ」
と言われたわけです。</p>

<p>戸惑った部分ですが、<a href="https://paiza.jp/poh/ec-campaign">新人プログラマー野田さんの課題</a>を
解いている過程で、「指定した金額以下で一番大きい金額のインデックス」が欲しい、と思ったのですよね。
結局それは<a href="http://docs.python.jp/3/library/bisect.html#bisect.bisect_left">bisect.bisect_left</a>を使って解決したんだけど、
bisect_leftの場合「返り値のインデックスの更に1コ前」が欲しい値だったわけです。</p>

<p>改めて二分探索の挙動について調べたところ、少なくともPython, Java共に、
あるデータが「挿入されてもソート状態が保たれる箇所」を探索してくれるものらしい。</p>

<p>例えば以下はPythonの例。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>import bisect
</span><span class='line'>
</span><span class='line'>a = [1, 2, 4, 8, 11]
</span><span class='line'>data = 6
</span><span class='line'>i = bisect.bisect(a, data)
</span><span class='line'># i の値は 3
</span><span class='line'>a.insert(i, data)
</span><span class='line'># a の値は [1, 2, 4, 6, 8, 11]</span></code></pre></td></tr></table></div></figure>


<p>なるほど。納得。</p>

<p>とは言え、カスタムの条件で二分探索したいケースもあると思うんですよね。例えば<a href="http://ja.wikipedia.org/wiki/%E6%8E%A5%E5%B0%BE%E8%BE%9E%E9%85%8D%E5%88%97">接尾辞配列</a>のように。</p>

<p>超簡単な例だと、こういうイメージ。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>txt = 'banana'
</span><span class='line'>suf = [i for i in range(len(txt))]
</span><span class='line'># suf の値は [0, 1, 2, 3, 4, 5]
</span><span class='line'>
</span><span class='line'>suf.sort(key=lambda i: txt[i:])
</span><span class='line'># suf の値は [5, 3, 1, 0, 4, 2]
</span><span class='line'>
</span><span class='line'>print([txt[i:] for i in suf])
</span><span class='line'># ['a', 'ana', 'anana', 'banana', 'na', 'nana'] が出力される。
</span><span class='line'># この結果は、全部分文字列がソートされた状態
</span><span class='line'>## a
</span><span class='line'>## ana
</span><span class='line'>## anana
</span><span class='line'>## banana
</span><span class='line'>## na
</span><span class='line'>## nana
</span><span class='line'># sufにはソートされた状態の各部分文字列へのインデックスが格納されている。
</span><span class='line'># この中から、例えば'an'が含まれる全ての箇所を探す、というのはbisectでは探索できない…</span></code></pre></td></tr></table></div></figure>


<p>こういう用途用の二分探索は、接尾辞配列ライブラリに含まれてると思うんですけどね。</p>

<p>少なくともPythonで言うと、リストの外の情報を使ってソートすることはできるけれど、
それに対する二分探索による探索がないのはちょっと不便な気がしたのです。
それを可能とするライブラリがあるのであれば、それを使うにして、
なければそれを実現するライブラリを作ろうかしら。</p>

<p>「それ～～でできるよ」情報があったらお教え下さいませ。</p>
]]></content>
  </entry>
  
</feed>
